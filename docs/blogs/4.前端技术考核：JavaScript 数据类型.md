# 前端技术考核：JavaScript 数据类型的检测、转换

￼目标读者：

- 分类
  - 前端
- 标签
  - JavaScript
  - 面试

## 0. 前言

大家好，我是纳撸多。今天要分享的内容是JS 基础之数据类型，让我们一起精进，成为更好的自己。

正如xxx所言，程序是由通过命令操作数据输出结果。可见数据类型是一切程序运行的基础。而数据有很多类型，如何进行类型判断、类型之间又是如何转换的，这些都是日常工作中需要掌握的。

文章大纲
通过阅读本文，你可以学到：

- JavaScript的数据类型有哪些？
- 这些数据类型是如何存储的？
- 如何进行数据类型判断？
- 如何进行数据类型的转换？

## 1.  JavaScript 数据类型有哪些?

ECMAScript 6 有7种数据类型，可以分为基本类型和复杂引用类型两种。

其中基本类型又分为数字类型 Number，非数字类型Null、Undefined、Symbol、String、Boolean。

复杂引用类型则是Object，但 Object 下又可以细分更多的引用类型。
- Array
- TypedArray
- Map
- WeakMap
- Set 
- WeakSet

## 2. 这些类型是如何存储的

这块可能放到深拷贝与浅拷贝的前置也适合，可以引用。

前面提到 JavaScript 数据分为引用类型和基本类型，其中基本存储在栈里，引用类型数据的值存储在堆里，地址则存储在堆里。

举个例子：

function foo(){
    var a = "极客时间"
    var b = a
    var c = {name:"极客时间"}
    var d = c
}
foo()

￼


那么这些数据又是如何销毁的？函数执行上下文执行完成后，JavaScript 引擎会把 ESP 指向外层的执行上下文，当前的执行上下文的栈数据则会被销毁。至于堆的数据，在 JavaScript 执行的时候，会通过静态分析标记数据的引用情况，在下一次垃圾回收时，不被引用的对象将会通过垃圾回收器进行回收。更多细节可以看  JavaScript 内存管理。

## 3. 如何进行类型判断

### 封装一个类型判断工具函数

举个例子

搜索需要判断类型的场景代码，比如搜索工具中 typeOf 被使用的地方。也可以 github 搜索。

ECMAScript 6有 7种数据类型。当我们使用 typeof 对这些数据类型的值进行操作的时候，返回的结果却不是一一对应，分别是：
undefined、object、boolean、number、string、object 

注意以上都是小写的字符串。Null 和 Object 类型都返回了 object 字符串。

可以使用 Object.prototype.toString() 进行判断，输出结果为 []

typeof 上场，Null 和 Object 类型都返回了 object 字符串。这是因为 Null 被认为是空对象指针，这是正确的行为。

### 常见的数据类型判断场景

为什么会有这么多的工具函数呢，明明一个 type 可以搞掂，为什么要分这么细？

1. isEmpty

2. isplainObject 

摘自 props 相关逻辑

```js
  /**

   * Get the raw type string of a value, e.g., [object Object].
     */
  var _toString = Object.prototype.toString;

  function toRawType (value) {
    return _toString.call(value).slice(8, -1)
  }

  /**

   * Strict object type check. Only returns true
   * for plain JavaScript objects.
     */
       function isPlainObject (obj) {

    return _toString.call(obj) === '[object Object]'

  }
```

3. window 对象
4. isArraylike
5. iselement
6. `isPrimitive`: 判断变量是否为原型类型
7. `isRegExp`: 判断变量是否为正则对象。
8. `isValidArrayIndex`: 判断变量是否含有效的数组索引
9. `isObject`: 区分对象和原始值

这些可以直接加代码片段 lodash

30seconds

### Vue 中的 props 是如何判断类型的？

在 Vue 中，我们常常在组件定义中添加 props来接收父组件传递的值，比如：

```js
export default {
  name: 'Camera',
  props: ['name', 'img'],
}
```

通常不建议这么写，应该为props对象指定类型：

```js
export default {
  name: 'Camera',
  props: {
      name: {
        type: String,
      },
      img: {
        type: String,
      }
  }
}
```

在Vue中，props 可以有很多不同的类型：

* String
* Number
* Boolean (true 或者 false)
* Array
* Object

我们为什么要向 props 添加类型？通过添加类型，我们可以设置我们期望收到的数据类型。如果我们将camera的props中的name设置为true，它将无法正常工作，因此 Vue 会警告我们使用错误。

![](../.vuepress/public/images/2021-03-06-22-21-27.png)

流程图：对每个点进行描述

在 Vue 初始化中会执行 `initProps` ，其中对 Props 的处理包括检验类型，具体 Vue 源码是这样判断的：

```js
function validateProp(key, propOptions, propsData, vm) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // boolean casting
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
      if (absent && !hasOwn(prop, "default")) {
        value = false;
      } else if (value === "" || value === hyphenate(key)) {
        // only cast empty string / same name to boolean if
        // boolean has higher priority
        var stringIndex = getTypeIndex(String, prop.type);
        if (stringIndex < 0 || booleanIndex < stringIndex) {
          value = true;
        }
      }
    }
    // check default value 检查默认值
    if (value === undefined) {
      value = getPropDefaultValue(vm, prop, key);
      // since the default value is a fresh copy,
      // make sure to observe it.
      var prevShouldObserve = shouldObserve;
      toggleObserving(true);
      observe(value);
      toggleObserving(prevShouldObserve);
    }
    {
      assertProp(prop, key, value, vm, absent);
    }
    return value;
  }
```

`props` 入参的复杂性导致了判断逻辑的复杂性，`validateProp` 主要就做 3 件事情：**处理 Boolean 类型的数据，处理默认数据，prop 断言，并最终返回 prop 的值**。

`assertProp`

```js
function assertProp (
  prop: PropOptions,
  name: string,
  value: any,
  vm: ?Component,
  absent: boolean
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    )
    return
  }
  if (value == null && !prop.required) {
    return
  }
  let type = prop.type
  let valid = !type || type === true
  const expectedTypes = []
  if (type) {
    if (!Array.isArray(type)) {
      type = [type]
    }
    for (let i = 0; i < type.length && !valid; i++) {
      const assertedType = assertType(value, type[i])
      expectedTypes.push(assertedType.expectedType || '')
      valid = assertedType.valid
    }
  }

  if (!valid) {
    warn(
      getInvalidTypeMessage(name, value, expectedTypes),
      vm
    )
    return
  }
  const validator = prop.validator
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      )
    }
  }
}
```

`assertProp` 函数的目的是断言这个 `prop` 是否合法。

首先判断如果 `prop` 定义了 `required` 属性但父组件没有传递这个 `prop` 数据的话会报一个警告。

接着判断如果 `value` 为空且 `prop` 没有定义 `required` 属性则直接返回。

然后再去对 `prop` 的类型做校验，先是拿到 `prop` 中定义的类型 `type`，并尝试把它转成一个类型数组，然后依次遍历这个数组，执行 `assertType(value, type[i])` 去获取断言的结果，直到遍历完成或者是 `valid` 为 `true` 的时候跳出循环。

```js
const simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/
function assertType (value: any, type: Function): {
  valid: boolean;
  expectedType: string;
} {
  let valid
  const expectedType = getType(type)
  if (simpleCheckRE.test(expectedType)) {
    const t = typeof value
    valid = t === expectedType.toLowerCase()
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value)
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value)
  } else {
    valid = value instanceof type
  }
  return {
    valid,
    expectedType
  }
}
```

`assertType` 的逻辑很简单，先通过 `getType(type)` 获取 `prop` 期望的类型 `expectedType`，然后再去根据几种不同的情况对比 `prop` 的值 `value` 是否和 `expectedType` 匹配，最后返回匹配的结果。

如果循环结束后 `valid` 仍然为 `false`，那么说明 `prop` 的值 `value` 与 `prop` 定义的类型都不匹配，那么就会输出一段通过 `getInvalidTypeMessage(name, value, expectedTypes)` 生成的警告信息，就不细说了。

最后判断当 `prop` 自己定义了 `validator` 自定义校验器，则执行 `validator` 校验器方法，如果校验不通过则输出警告信息。

## 4. 如何进行数据类型转换

一般使用要转换的目标类型所对应的构造函数来进行强制转换，有些情况则会发生隐形转换，比如在四则运算的过程中。

### 各种类型相互转换

1. 其他数据类型转字符串类型

| 数据类型  | String 类型            |
| --------- | ---------------------- |
| Number    | 转化为数字对应的字符串 |
| Boolean   | "true" / "false"       |
| Null      | "null"                 |
| Undefined | "undefined"            |
| Symbol    | "Symbol(xx)"           |
| Object    | "[object Object]"      |

```js
String(123);      // "123"
String(true);     // "true"
String(null);     // "null"
String(undefined);// "undefined"
String([1,2,3])   // "1,2,3"
String({});		  // "[object Object]"
String(Symbol()); // "Symbol()"
```

2. 其他数据类型转布尔类型

除了特殊的几个值 `""`、`undefined`、`NaN` `null` `false` `0` 转化为 `Boolean` 为 `false` 之外，其他类型值都转化为 `true`。

```js
Boolean('')         // false
Boolean(undefined)  // false
Boolean(null)       // false
Boolean(NaN)        // false
Boolean(false)      // false
Boolean(0)          // false
Boolean({})		    // true
Boolean([])		    // true
```

3. 转换为数字类型

| 数据类型  | Number 类型                                                  |
| --------- | ------------------------------------------------------------ |
| String    | 1) 数字转化为对应的数字，空字符串转化为 0<br> 2)其他转化为 NaN |
| Boolean   | 1) true -> 1 <br> 2)false -> 0                               |
| Null      | 0                                                            |
| Undefined | NaN                                                          |
| Symbol    | 抛出错误                                                     |
| Object    | NaN                                                          |
| Array     | 1) 数组为空转化为 0; <br> 2) 数组只有一个数字元素; <br> 3) 其他转化为 NaN |

```js
Number(10);        // 10 
Number('10');      // 10 
Number(null);      // 0  
Number('');        // 0  
Number(true);      // 1  
Number(false);     // 0  
Number([]);        // 0 
Number([1,2]);     // NaN
Number('10a');     // NaN
Number(undefined); // NaN
```

4. 对象类型转为原始类型

对象类型在转原始类型的时候，会调用内置的 `valueOf()` 和 `toString()` 方法，这两个方法是可以进行重写的。

转化为原始类型分为两种情况：转化为字符串类型或其他原始类型。

- 如果转字符串类型，就调用内置函数中的 `toString()` 方法。
- 如果是其他基本类型，则调用内置的 `valueOf()` 方法。

5. 原始值转对象

### 常见的数据转换场景

1. 基本类型与引用类型

2. 函数传参

3. null 和 undefined

## 5. 小结

## 参考资料

- https://juejin.cn/post/6844904104402092039

- https://juejin.cn/post/6844903485348020237

- https://juejin.cn/post/6844903486317035534

- 「从源码中学习」彻底理解Vue选项Props 
  https://juejin.cn/post/6844903796426932232