# 专业拆造轮子系列之按钮篇

仿造：JS 原生 Button —— Vue Button，各自造一个仓库，都是作为学习用。- react Button

设计规范样式，可以仿造 antd-design 的设计

仓库仿造学习：https://github.com/alexwolfe/Buttons，
学习版本：v2.0.0


构思

类型

## 打包后的文件分析：全局运行机制

### 安装使用

```html
  <!-- Buttons core css -->
  <link rel="stylesheet" href="css/buttons.css">

  <!-- Only needed if you want support for dropdown menus -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
  <script type="text/javascript" src="js/buttons.js"></script>

  <!-- Only needed if you want font icons -->
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
```
### Buttons.js

通过立即执行函数，注册到用户的运行环境上，依赖于 jQuery，把 jQuery 传递给 IIFE（立即执行函数），并通过它映射为 $，这样就避免了在执行的作用域被其他库覆盖。 

**上下文：**
```js
// the semi-colon before function invocation is a safety net against concatenated
// scripts and/or other plugins which may not be closed properly.
;(function ( $, window, document, undefined ) {
  'use strict';
  //  ....
  // undefined is used here as the undefined global variable in ECMAScript 3 is
  // mutable (ie. it can be changed by someone else). undefined isn't really being
  // passed in so we can ensure the value of it is truly undefined. In ES5, undefined
  // can no longer be modified.

  // window and document are passed through as local variable rather than global
  // as this (slightly) quickens the resolution process and can be more efficiently
  // minified (especially when both are regularly referenced in your plugin).

})( jQuery, window, document);
```

这个逻辑主要是针对下拉框，给按钮绑定一些事件。

其中 jQuery 的插件化思想可以学习下：

**编写插件**：
```js
  // Create the defaults once
  var pluginName = "menuButton";
  var menuClass = ".button-dropdown";
  var defaults = {
    propertyName: "value"
  };  
 // The actual plugin constructor
 /**
   * @description: 
   * @param {Object} element
   * @param {Object} options 配置项目
   */
  function Plugin( element, options ) {

    //SET OPTIONS
    this.options = $.extend( {}, defaults, options );
    this._defaults = defaults;
    this._name = pluginName;

    //REGISTER ELEMENT
    this.$element = $(element);

    //INITIALIZE
    this.init();
  }

  Plugin.prototype = {
    constructor: Plugin,

    init: function() {
      // WE DON'T STOP PROPGATION SO CLICKS WILL AUTOMATICALLY
      // TOGGLE AND REMOVE THE DROPDOWN
      this.toggle();
    },

    toggle: function(el, options) {
      if(this.$element.data('dropdown') === 'show') {
        this.hideMenu();
      }
      else {
        this.showMenu();
      }
    },

    showMenu: function() {
      this.$element.data('dropdown', 'show');
      this.$element.find('ul').show();
      this.$element.find('.button:first').addClass('is-active');
    },

    hideMenu: function() {
      this.$element.data('dropdown', 'hide');
      this.$element.find('ul').hide();
      this.$element.find('.button:first').removeClass('is-active');
    }
  };
```

**注册插件：**

要编写一个 jQuery 插件，需要为 jQuery.fn 对象增加一个新的函数属性，属性名就是插件的名字。

```js
  // A really lightweight plugin wrapper around the constructor,
  // preventing against multiple instantiations
  $.fn[pluginName] = function ( options ) {
    // 这里的 this 指向 jQuery 对象
    // 返回 this 关键字，保持调用链接性
    return this.each(function () {
      // 在这里 this 指向 DOM 元素
      // TOGGLE BUTTON IF IT EXISTS
      if ($.data(this, "plugin_" + pluginName)) {
        // 取出之前的实例化的 plugin 值，进行调用
        $.data(this, "plugin_" + pluginName).toggle(); 
      }
      // OTHERWISE CREATE A NEW INSTANCE
      else {
        // 把 new 实例化的东西进行存储到 data 里
        $.data(this, "plugin_" + pluginName, new Plugin( this, options )); 
      }
    });
  };

```

**使用插件：**
```js
  //DELEGATE CLICK EVENT FOR DROPDOWN MENUS
  $(document).on('click', '[data-buttons=dropdown]', function(e) {
    var $dropdown = $(e.currentTarget);
    $dropdown.menuButton(); // 使用插件
  });
```

**jQuery 插件化思想总结**
- 总是把插件包装在闭包中`{/* plugin goes here */}(jQuery)`。
- 不要在插件函数的立即作用域中额外包装 this 关键字。
- 总是让插件函数返回 this 关键字以保持 chainability，除非插件有真正的返回值。
- 不要传给插件大量参数，应该传一个可以覆盖插件默认选项的设置对象。
- 在单个插件中，不要让一个以上的名称空间搞乱了 jQuery.fn 对象。
- 总是为方法、事件和数据定义名称空间。
### Buttons.css

主要的样式组成如下：
- Button Defaults 默认样式
- Button Colors
- Button Shapes
- Button Sizes
- Color Mixin
- Base Button Style

默认命名空间，主要是 `.button`，整体以 - 为分隔，形成独立的单元，可以随意组合。

也运用到了元素的多种状态处理
- :active
- :hover
- :focus
- :disabled



其他官方的说明：
- Compass has been replaced with [autoprefixer](https://github.com/postcss/autoprefixer). Compass is not recommended but it is still supported.
- Button colors are now complete independent (ex. `button-primary`) we no longer have classes like `button-flat-primary` to achieve this you now simply add `button-flat` `button-primary`
- Buttons styles are now independent (ex. `button-flat`, `button-3d`, etc.). You can apply these styles and they will automatically pick up the color attached to the button (ex. button-primary button-3d)


## src 源码查看
## 参考资料

- [创建插件](https://gist.github.com/quexer/3619237) 很详细的关于 jQuery 创建插件的方方面面，包括数据、事件编写等最佳实践，其中命名空间这块挺值得学习的，如何更好地注册，更彻底的卸载。