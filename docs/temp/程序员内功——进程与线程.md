# 程序员内功——进程与线程

- CPU 计算
- 进程与线程
- 为什么要用多线程
- 多线程一定比单线程要快吗？
  - 什么时候使用多线程
  - 什么时候使用用单线程
- 如果采用单线程，要如何提效
  - js 单线程如何提效（事件驱动）
  - redis 单线程如何提效

## 前言

<!-- 这个知识很多地方都用到，干脆写一篇文章来对知识进行聚合 -->

运行速率 CPU > 内存 > 硬盘

现代操作系统（Window，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务，例如：

CPU 执行代码都是一条条顺序执行的，但是，<u>即使是单核 CPU，也可以同时运行多个任务。因为操作系统执行多任务实际上就是让 CPU 对多个任务轮流交替执行。</u>

## CPU 计算任务

## 进程与线程

在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和 Word 都是进程。

进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程，一个主线程。

多线程切换成本比多进程切换成本要低。

### 进程和线程之间的关系

#### 进程中的任意一线程执行出错，都会导致整个进程的崩溃。

#### 线程之间共享进程中的数据

![](../.vuepress/public/images/2020-06-19-12-46-11-multiple-thread-in-process.png)

因此如果线程 A 和线程 B 同时操作某一块数据的话，有必要同步锁住其中一个。例如浏览器渲染进程的 JS 线程与渲染线程。

#### 当一个进程关闭之后，操作系统就会回收进程所占用的内存

#### 进程之间的内容相互隔离

### 浏览器历史架构回顾

浏览器架构变迁

单进程、单线程
- 不稳定
- 不流畅
- 安全

多进程

目前多进程
- 浏览器进程
- 渲染进程
- GPU 进程（目前chrome 无论是否 3D，都用 GPU进程 进行页面渲染。）
- 网络进程
- 插件进程

多进程
- 更高的资源占用。
- 更复杂的体系架构

### 多线程

Java 语言内置了多线程支持：一个 Java 程序实际上是一个 （虚拟机）JVM 进程，JVM 进程用一个主线程来执行 `main()` 方法，在 `main()` 方法内部，我们又可以启动多个线程。此外，JVM 还有负责垃圾回收的其他工作线程等。

![](../.vuepress/public/images/2020-06-19-10-44-43-java-thread.png)

java.lang.Thread 是个表示线程的类，它有启动线程、连接线程和让线程闲置的方法（这里列出重要的几个）。

当有超过一个以上的`执行空间`时，看起来会像是有好几件事同时发生。实际上，只有真正的多处理器系统能够同时执行好几件事情，但使用 Java 的线程可以让它看起来好像同时都在执行中。也就是说，<u>执行动作可以在执行空间非常快速地来回切换，因此你会感觉到每项任务都在执行。</u>

即使是多核 CPU，因为通常任务的数量远远多于 CPU 的核数，所以任务也是交替执行的。也就是说是并发，而不是并行计算。

### 实现多线程

线程是独立的线程，它代表独立的执行空间。每个 Java 应用程序会启动一个主线程——将 `main()` 放在它自己执行空间的最开始处。
要记得 Java 也只是个在底层操作系统上执行的进程。一旦轮到 Java 执行的时候，Java 虚拟机实际上会执行什么？哪个字节码会被执行？答案就是目前执行空间最上面的会被执行！在 100 个毫秒内，目前执行程序代码可能会被切换到不同空间上的不同方法内。

每个 Thread 需要一个任务来执行，一个可以放在执行空间的任务。实现多任务计算。

```java
public class Main {
	public static void main(String[] args) {
		new Thread1().start();
		new Thread2().start();
		System.out.println("back in main");
	}

}
class Thread1 extends Thread {
  @Override
	public void run() {
			System.out.println("Thread-1: running...");
		}
	}
}

class Thread2 extends Thread {
  @Override
	public void run() {
			System.out.println("Thread-2: running...");
		}
	}
}
```

虽然是多线程执行，但是由于要执行的任务多，导致线程多于 CPU 的数量，因此还需要有`线程调度器`(scheduler)的出现，来处理线程的执行问题。

线程调度器会决定哪个线程从等待状况中被挑出来运行，以及何时把哪个线程送回等待被执行的状态。它会决定某个线程要运行多久，当线程被踢出时，调度器也会指定线程要回去等待下一个机会或者是暂时地堵塞。

比如，浏览器的渲染进程中，不能让 JS 线程一直在执行，在它执行完一个宏任务后，就阻塞它（locked）（如果这个宏任务太久了，就有必要开启多个 worker 线程了），让渲染线程来绘制画面。

两个线程就开始同时运行了，并且由操作系统调度，程序本身无法确定线程的调度顺序。要模拟并发执行的效果，可以让线程睡眠。

### 多线程的并发问题

`并行性（concurrency）`问题会引发`竞态状态（condition）`。竞争状态会引发数据的损毁。

这一切都来自于可能发生的一种状况，两个或两个以上的线程存取单一对象的数据。也就是说两个不同执行空间上的方法都在堆上对同一个对象执行 `getter` 或 `setter`。

两个线程各自认为自己是宇宙的中心，只关心自己的任务。因为线程会被打入可执行状态，此时基本上是昏迷过去的，当它回到执行中的状态时，根本不知道自己曾经不省人事。

#### 加锁

应用：单例模式（如果多个线程读取，会 new 的时候有问题）

## 为什么要用多线程

<!-- 回顾历史：

单核 CPU 的出现是解决了什么？双核是解决了什么。进程的出现。多进程的出现。线程的出现。多线程的出现。 -->
<u>使用多线程的最大原因是因为单线程只会映射到一个 CPU 上，而多线程会映射到多个 CPU 上。</u>对于多 CPU 而言，是最大限度地利用 CPU 资源。现今，新出的电脑几乎都是两核以上的了。

对于在单核 CPU 采用多线程的话，不会提供程序的执行速度，因为线程切换需要消耗时间，但对于用户来说，可以减少用户的响应时间。比如要执行一个网络任务，单线程需要一直在等待中，这是 CPU 不能做其他事情。

至于浏览器所说的事件驱动，这也是浏览器渲染进程的`事件触发线程`合作把事件添加进任务队列 ，才能使 JS 单线程提取能够来异步执行请求任务（但是如果这个异步请求事件触发频率很高，那么 `JS 引擎单线程`还是会影响阻塞 `渲染线程`，就会导致有问题，才会有 `WebWorker` 处理。至于长轮询，可以使用 socket 来处理，服务端推送信息。

创建 Worker 时，JS 引擎向浏览器申请开一个`子线程`（子线程是浏览器开的，完全受`主线程`控制，而且不能操作 DOM）。JS 引擎线程与 worker 线程间通信通过特定的方式通信（postMessage API，需要通过序列号对象来与线程交互特定的数据）。）

Java 本身支持多线程，对于不支持多线程的 JS 也可以向浏览器申请子线程来做非常耗时的工作如解码视频。而 JS 引擎是单线程的，这一点的本质仍然未改变，Worker 可以理解是浏览器给 JS 引擎开的外挂，专门用来解决那些大量计算问题。

目前 Web Worker 有：
- Service Worker ，需要支持 https 协议。
- WebWorker
- SharedWorker

## 多线程一定比单线程跑得快吗？

多线程会缓慢的原因：上下文切换、创建线程开销。

首先单线程不会切换，这样它一直在执行这个线程照道理不是更快吗？但是就没有很好地利用多核处理器的优势了，而是有时候我们不想计算机一直执行某个计算任务，应该在 A 任务。如果 java 多线程在单核计算机里又是如何被对待呢？（浏览器渲染进程：JS 语言没有支持多线程，JS 单线程通过事件驱动来处理，关联了任务队列。）

Java 多线程编程的特点又在于：
- 多线程模型是 Java 程序最基本的并发模型；
- 后续读写网络 、数据库、Web 开发等都依赖 Java 多线程基础。

## 如果采用单线程，要如何提效

### 为什么 JavaScript 是单线程？

JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。

JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript s的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

为了利用多核 CPU 的计算能力，HTML5 提出 `Web Worker` 标准，允许 JavaScript 脚本创建多个线程，<u>但是子线程完全受主线程控制，且不得操作 DOM</u>。所以，这个新标准并没有改变 JavaScript 单线程的本质。

创建 Worker时，JS 引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
JS 引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）

#### 浏览器主线程就是 js 引擎线程吗？

不是，浏览器主线程 跟 js 引擎线程分开的，可以在 js 引擎线程中编写 Web Worker 申请线程。

The main thread is where a browser processes user events and paints. By default, the browser uses a single thread to run all the JavaScript in your page, as well as to perform layout, reflows, and garbage collection. This means that long-running JavaScript functions can block the thread, leading to an unresponsive page and a bad user experience.

Unless intentionally using a web worker, such as a service worker, JavaScript runs on the main thread, so it's easy for a script to cause delays in event processing or painting. The less work required of the main thread, the more that thread can respond to user events, paint, and generally be responsive to the user.

- [Main thread](https://developer.mozilla.org/en-US/docs/Glossary/Main_thread#:~:text=The%20main%20thread%20is%20where%20a%20browser%20processes%20user%20events%20and%20paints.&text=Unless%20intentionally%20using%20a%20web,in%20event%20processing%20or%20painting.)


### 在线程运行过程中处理新任务

并不是搜有的任务都是在执行之前就安排好的，大部分情况下，刷新的任务是在线程运行过程中产生的。

要想在线程运行过程中，能接收并执行新的任务，就需要采用`事件循环机制`。

判断是否有事件发生触发新的任务，激活线程执行。

### 处理其他线程发送过来的任务

事件循环只是解决了线程内部的任务问题，如果另外一个线程想让主线程执行一个任务，就需要用到`消息队列`。

![](../.vuepress/public/images/2020-06-19-16-48-43-messager-event-loop.png)

注：这里的 IO 线程包括（事件触发线程、异步请求线程等）？

通过消息队列，我们实现了线程之间的消息通信。

例如一个鼠标点击事件，通过事件触发线程发送消息给主线程的消息队列，主线程执行的任务都全部从消息队列中获取。所以如果有其他线程想要发送任务让主线程去执行，只需要将任务添加到该消息队列中就可以了

```bash
Task clickTask;
task_queue.pushTask(clickTask)
```

### 处理其他进程发送过来的任务

通过消息队列，我们实现了线程之间的消息同学。在 Chrome 中，跨进程之间的任务也是频繁发生的，那么如何处理其他进程发送过来的任务？

![](../.vuepress/public/images/2020-06-20-19-49-45-process-communicate.png)

### 消息队列中的任务类型

内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等。

除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。

以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。

#### GUI 渲染线程与 JS 引擎线程互斥

因为 JS 引擎可以修改 DOM 树，那么如果 JS 引擎在执行修改了 DOM 结构的同时，GUI 线程也在渲染页面，那么这样就会导致渲染线程获取的 DOM 的元素信息可能与 JS 引擎操作 DOM 后的结果不一致。为了防止这种现象，GUI 线程与 JS 线程需要设计为互斥关系，当 JS 引擎执行的时候，GUI 线程需要被冻结，但是 GUI 的渲染会被保存在一个队列当中，等待 JS 引擎空闲的时候执行渲染。
由此也可以推出，<u>如果 JS 引擎正在进行 CPU 密集型计算，那么 JS 引擎将会阻塞，导致主线程执行的这个 JS 任务长时间不空闲，</u>导致渲染进程一直不能执行渲染，页面就会看起来卡顿卡顿的，渲染不连贯，所以，要尽量避免 JS 执行时间过长。

#### JS 引擎线程与事件触发线程、定时触发器线程、异步H TTP请求线程

JS 执行任务也是在主线程，那其他线程在干嘛？ JS 单线程用来做什么的？

主线程就是 JS 线程，

事件触发线程、定时触发器线程、异步HTTP请求线程三个线程有一个共同点，那就是使用回调函数的形式，当满足了特定的条件，这些回调函数会被执行。这些回调函数被浏览器内核理解成事件，发送消息给主线程，添加进去`任务队列`，遇到需要执行的 JS 任务，则等待 JS 引擎空闲执行。（JS 引擎线程本身也维护了自己的任务队列。

主线程这里相当于是一个调度的作用，执行 JavaScript 时，会让 JS 线程来做这个工作。只不过它相当于一个入口，就像 Java 中的 `main()` 线程一样。例如事件触发线程会在异步网络请求完成后，会把这个新任务提交到主线程，主线程执行后就会调用 JS 线程来执行回调函数，如果这个执行 JS 任务过久的话，就会阻塞页面的渲染，Chrome 锁定了 DOM。GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行，因此才会有 worker 申请子线程。

### 消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务

通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了`实时性`问题。

主线程执行完一个宏任务后，就会进行渲染线程执行绘制画面了。


## 小结

## 参考资料

- [浏览器工作原理与实践](https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86)
- [面试官：多线程一定比单线程跑得快吗？](https://zhuanlan.zhihu.com/p/95005766)
- [多线程就一定比单线程快吗？](https://blog.csdn.net/u013568373/article/details/93488554)
- [多线程为什么比单线程快呢？](https://blog.csdn.net/BigJacky/article/details/51588956)
- 《Java 并发编程》
- 《Head First Java》
- [浅谈浏览器多进程与JS线程](https://segmentfault.com/a/1190000013083967#item-6-2)
- [JavaScript单线程与异步](https://cloud.tencent.com/developer/article/1393277)
- [Java主线程和其余线程的区别和实践（Main、Runnable、Thread）](https://blog.csdn.net/wd2014610/article/details/85291597)
- [javascript既然是单线程语言 ， 为什么会分主线程和消息线程(event loop) ?]()
- [JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)
- [史上最全！图解浏览器的工作原理](https://www.infoq.cn/article/CS9-WZQlNR5h05HHDo1b)