# SQL

## 前言

什么是 SQL？简单来说，SQL 就是访问和处理关系数据库的计算机标准语言。也就是说，无论用什么编程语言（Java、Python、C++...）编写程序，只要涉及到操作关系数据库，比如，一个电商网站需要把用户和商品信息存入数据库，或者一个手机游戏需要把用户的道具、通关信息存入数据库，都必须通过 SQL 来完成。

所以，现代程序离不开关系数据库，要使用关系数据库就必须掌握 SQL。

### NoSQL

你可能还听说过 NoSQL 数据库，也就是非 SQL 的数据库，包括 MongoDB、Cassandra、Dynamo 等等，它们都不是关系数据库。有很多人鼓吹现代 Web 程序已经无需关系数据库了，只需要使用 NoSQL 就可以。但事实上，SQL 数据库从始至终从未被取代过。回顾一下 NoSQL 的发展历程：

- 1970: NoSQL = We have no SQL
- 1980: NoSQL = Know SQL
- 2000: NoSQL = No SQL!
- 2005: NoSQL = Not noly SQL
- 2013: NoSQL = No, SQL!

今天，SQL 数据库仍然承担了各种应用程序的核心数据存储，而 NoSQL 数据库作为 SQL 数据库的补充钙，两者不再是二选一的问题，而是`主从关系`。所以，无论水用哪种编程语言，无论是 Web 开发、游戏开发还是手机开发，掌握 SQL，是所有软件开发人员所必须的。

## 关系数据库概述

为什么需要数据库？

因为应用程序需要保存用户的数据，比如 Word 需要把用户文档保存起来，以便下次继续编辑或者拷贝到另一台电脑。

要保存用户的数据，一个最简单的方法是把用户数据写入文件。例如，要保存一个班级所有学生的信息，可以向文件中写入一个 `CSV` 文件：

```bash
id,name,gender,score
1,小明,M,90
2,小红,F,95
3,小军,M,88
4,小丽,F,88
```

如果要保存学习所有班级的信息，可以写入另一个 CSV 文件。

但是，随着应用程序的功能越来越复杂，数据量越来越大，如何管理这些数据就成了大问题：

- 读写文件并解析出数据需要大量重复代码；
- 从成千上万的数据中快速查询出指定数据需要复杂的逻辑。

如果每个应用程序都各自自己写自己的读写数据的代码，一方面效率低，容易出错，另一方面，每个应用程序访问数据的接口都不相同，数据难以复用。

所以，数据库作为一种专门管理数据的软件就出现了。应用程序不需要自己管理数据，而是通过数据库软件提供的接口来读写数据。至于数据本身如何存储到文件，那是数据库软件的事情，应用程序自己并不关心：

```bash
┌──────────────┐
│ application  │
└──────────────┘
       ▲│
       ││
   read││write
       ││
       │▼
┌──────────────┐
│   database   │
└──────────────┘
```

这样一来，编写应用程序的时候，数据读写的功能就被大大地简化了。

### 数据模型

数据库按照数据结构来组织、存储和管理数据，实际上，数据库就一共有三种模型：

- 层次模型
- 网状模型
- 关系模型

层次模型就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一棵树：

```bash
            ┌─────┐
            │     │
            └─────┘
               │
       ┌───────┴───────┐
       │               │
    ┌─────┐         ┌─────┐
    │     │         │     │
    └─────┘         └─────┘
       │               │
   ┌───┴───┐       ┌───┴───┐
   │       │       │       │
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│     │ │     │ │     │ │     │
└─────┘ └─────┘ └─────┘ └─────┘
```

网状模型把每个数据节点和其他节点都连接起来，它的数据结构看起来就像很多城市之间的路网：

```bash
  ┌─────┐      ┌─────┐
   ┌─│     │──────│     │──┐
   │ └─────┘      └─────┘  │
   │    │            │     │
   │    └──────┬─────┘     │
   │           │           │
┌─────┐     ┌─────┐     ┌─────┐
│     │─────│     │─────│     │
└─────┘     └─────┘     └─────┘
   │           │           │
   │     ┌─────┴─────┐     │
   │     │           │     │
   │  ┌─────┐     ┌─────┐  │
   └──│     │─────│     │──┘
      └─────┘     └─────┘
```

关系模型把数据看作是一个二维表格，任何数据都可以通过行号 + 列号来唯一确定，它的数据类型看起来就是一个 Excel 表：

```bash
┌─────┬─────┬─────┬─────┬─────┐
│     │     │     │     │     │
├─────┼─────┼─────┼─────┼─────┤
│     │     │     │     │     │
├─────┼─────┼─────┼─────┼─────┤
│     │     │     │     │     │
├─────┼─────┼─────┼─────┼─────┤
│     │     │     │     │     │
└─────┴─────┴─────┴─────┴─────┘
```

随着时间的推移和市场竞争，最终，基于关系模型的关系数据库获得了绝对市场份额。

因为相比层次模型和网状模型，关系模型理解和使用起来最简单。（对于前端同学，可能 MongoDB 的层次模型更熟悉点）。

关系数据库的关系是基于数学理论建立的，复杂难懂。我们可以基于日常生活的来进行理解。我们以学校班级为例，一个班级的学生就可以用一个表格存起来，并且定义如下：

| ID  | 姓名 | 班级 ID | 性别 | 年龄 |
| --- | ---- | ------- | ---- | ---- |
| 1   | 小明 | 201     | M    | 9    |
| 2   | 小红 | 202     | F    | 8    |
| 3   | 小军 | 202     | M    | 8    |
| 4   | 小白 | 201     | F    | 9    |

其中，班级 ID 对应着另一个班级表：

| ID  | 名称       | 班主任 |
| --- | ---------- | ------ |
| 201 | 二年级一班 | 王老师 |
| 202 | 二年级二班 | 李老师 |

通过给定一个班级名称，可以查到一条班级记录，根据班级 ID，又可以查到多条学生记录，这样，<u>二维表就通过 ID 映射建立了“一对多”关系。</u>

### 数据类型

对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等。

| 名称         | 类型           | 说明                                                                                       |
| ------------ | -------------- | ------------------------------------------------------------------------------------------ |
| INT          | 整型           | 4 字节整数类型，范围约+/-21 亿                                                             |
| BIGINT       | 长整型         | 8 字节整数类型，范围约+/-922 亿亿                                                          |
| REAL         | 浮点型         | 4 字节浮点数，范围约+/-1038                                                                |
| DOUBLE       | 浮点型         | 8 字节浮点数，范围约+/-10308                                                               |
| DECIMAL(M,N) | 高精度小数     | 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共 20 位，其中小数 10 位，通常用于财务计算 |
| CHAR(N)      | 定长字符串     | 存储指定长度的字符串，例如，                                                               |  | CHAR(100)总是存储 100 个字符的字符串 |
| VARCHAR(N)   | 变长字符串     | 存储可变长度的字符串，例如，VARCHAR(100)可以存储 0~100 个字符的字符串                      |
| BOOLEAN      | 布尔类型       | 存储 True 或者 False                                                                       |
| DATE         | 日期类型       | 存储日期，例如，2018-06-22                                                                 |
| TIME         | 时间类型       | 存储时间，例如，12:20:59                                                                   |
| DATETIME     | 日期和时间类型 | 存储日期+时间，例如，2018-06-22 12:20:59                                                   |

上面的表中列举了最常用的数据类型。很多数据类型还有别名，例如，`REAL` 又可以写成 `FLOAT(24)`。还有一些不常用的数据类型，例如，`TINYINT` （范围在 0~255）。各数据库厂商还会主持特定的数据雷系你噶，例如 `JSON`。

<u>选择数据类型的时候，要根据业务规则选择合适的类型。</u>通常来说，`BIGINT` 能满足整数存储的需求，`VARCHAR(N)` 能满足字符串存储的需求，这两种类型是使用最广泛的。

### 主流数据库：

目前，主流的关系数据库主要分为以下几类：

1. 商用数据库，例如：[Oracle](https://www.oracle.com/)、SQL Server、DB2 等；
2. 开源数据库，例如：MySQL，PostgreSQL 等；
3. 桌面数据库，以微软 Access 为代表，适合桌面应用程序使用；
4. 嵌入式数据库，以 Sqlite 为代表，适合手机应用和桌面程序。

### SQL

什么是 SQL？SQL 是`结构化查询语言`（Structured Query Language）的缩写，用来访问和操作数据库系统。<u>SQL 语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行灌流和维护操作。</u>不同的数据库，都支持 SQL，这样，我们通过学习 SQL 这一种语言，就可以 i 操作各种不同的数据库。

虽然 SQL 已经被 ANSI 组织定义为标准，不幸的是，各个不同的数据库对标准的 SQL 支持不太一致。并且，大部分数据都在标准的 SQL 上做了扩展。也就是说，<u>如果只使用标准 SQL，理论上所有数据库都可以支持，</u>但如果使用某个特定数据库的扩展 SQL，换一个数据库就不能执行了。例如，Oracle 把自己扩展的 SQL 称为 `PL/SQL`，Microsoft 把自己扩展的 SQL 称为 `T-SQL`。

现实情况是，如果我们只使用标准 SQL 的核心功能，那么所有数据库通常都可以执行。不常用的 SQL 功能，不同的数据库的支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。

总的来说，SQL 语言定义了这么几种操作数据库的能力：

**DDL：Data Definition Language**

DDL 允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。<u>通常，DDL 由数据库管理员执行。</u>

**DML：Data Manipulation Language**

DML 为用户提供添加、删除、更新数据的能力 i，这些是应用程序对数据库的日常操作。

**DQL：Data Query Language**

DQL 允许用户查询数据，这也是通常最频繁的数据库日常操作。

### 语法特点

SQL 语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在 Linux 上区分大小写，有的在 Windows 上不区分大小写。

所以，本教程约定：SQL 关键字总是大写，以示突出，表名和列名均使用小写。

## 关系模型

我们已经知道，关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的二维表，可以把它们看作很多 Excel 表。

表的每一行称为`记录（Record）`，记录是一个逻辑意义上的数据。

表的每一列称为`字段（Column）`，同一个表的每一行记录都拥有相同的若干字段。

字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为 `NULL`。注意 `NULL` 表示字段数据不存在。一个整型字段如果为 `NULL` 不表示它的值为 `0`，同样的，一个字符串字段为 `NULL` 也不标水它的值为空串`''`。

⚠️：通常情况下，字段应该避免允许为 NULL。<u>不允许为 NULL 可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为 NULL。</u>

和 Excel 表有所不同的是，关系数据库的表和表之间需要建立`“一对多”`和 `“多对一”`、`“一对一”`的关系，这样才能够按照应用程序的逻辑来组织和存储数据。

例如，一个班级表：

| ID  | 名称       | 班主任 |
| --- | ---------- | ------ |
| 201 | 二年级一班 | 王老师 |
| 202 | 二年级二班 | 李老师 |

每一行对应着一个班级，而一个班级对应着多个学生，所以班级表和学生表的关系就是`“一对多”`。

| ID  | 姓名 | 班级 ID | 性别 | 年龄 |
| --- | ---- | ------- | ---- | ---- |
| 1   | 小明 | 201     | M    | 9    |
| 2   | 小红 | 202     | F    | 8    |
| 3   | 小军 | 202     | M    | 8    |
| 4   | 小白 | 201     | F    | 9    |

反过来，如果我们先在学生表中定位了一行记录，例如 `ID=1` 的小明，要确定他的班级，只需要根据他的“班级 ID”对应的值 `201` 找到班级表中 `ID=201` 的记录，即二年级一班。所以，学生表和班级表是`多对一`的关系。

如果我们把班级表分拆得细一点，例如，单独创建一个教师表：

| ID  | 名称   | 年龄 |
| --- | ------ | ---- |
| A1  | 王老师 | 26   |
| A2  | 张老师 | 39   |
| A3  | 李老师 | 32   |
| A4  | 赵老师 | 27   |

这样，一个班级总是对应一个教师，班级表和教师表就是“一对一”关系。

可以运用关系模型来编写 Web 视图界面，例如树结构与 tab 列表的联动。

在关系数据库中，关系是通过`主键`和`外键`来维护的。

### 主键

在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，`students` 表的两行记录：

| id class_id | name | gender | score |
| ----------- | ---- | ------ | ----- |
| 1           | 1    | 小明   | M     | 90 |
| 2           | 1    | 小红   | F     | 95 |

每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。

<u>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为`主键`。</u>

例如，假设我们把 `name` 字段作为主键，那么通过名字 `小明` 或 `小红` 就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同的主键的两条记录是不被允许的。

⚠️：<u>对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为`主键是用来唯一定位记录的`，修改了主键，会造成一系列的影响。</u>

由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景。如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。

<u>所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。</u>

因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均`不可`用作主键。

作为主键最好是完全业务无关的字段，我们一般把这个字段命名为 `id`。常见的可作为 `id` 字段的类型有：

1. `自增整数类型`：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；
2. `全局唯一 GUID 类型`：使用一种全局唯一的字符串作为主键，类似 `8f55d96b-8acc-4636-8cb8-76bf8abc2f57`。GUID 算法通过`网卡 MAC 地址`、`时间戳` 和`随机数`保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了 GUID 算法，可以自己预算出主键。

对于大部分应用来说，通常自增类型的主键就能满足需求。我们在 `students` 表中定义的主键也是 `BIGINT NOT NULL AUTO_INCREMENT` 类型。

⚠️ 如果使用 `INT` 自增类型，那么当一张表的记录树超过 2147483647（约 21 亿）时，会达到上限而出错。使用`BIGINT`自增类型则可以最多约 922 亿亿条记录。

#### 联合主键

官修数据库实际上还允许通过`多个字段唯一标识记录·，即两个或更多的字段都设置为主键，这种主键被称为联合主键。

对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：

|id_num	|id_type|	other columns...|
|--|--|--|
|1	|A	|...
|2	|A	|...
|2	|B	|...

如果我们把上述表的 `id_num` 和 `id_type` 这两列作为联合主键，那么上面的 3 条记录都是允许的，因为没有两列主键组合起来是相同的。

没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。

#### 小结

主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应用使用 BIGINT 自增或 GUID 类型。主键也不应用允许 `NULL`。

可以使用多个列作为联合主键，但联合主键并不常用。

### 外键

当我们用主键唯一标识记录时，我们就可以在 `stundents` 表中确定任意一个学生的记录：

|id	|name	|other columns...|
|--|--|--|
|1	|小明	|...|
|2	|小红	|...|

我们还可以在 `classes` 表中确定任意一个班级记录：

|id	name	|other columns...|
|--|--|--|
|1	|一班|	...|
|2	|二班|	...|

但是我们如何确定 `students` 表的一条记录，例如，`id=1` 的小明，属于哪个班级呢？

由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个 `classes` 的记录可以对应多个 `students` 表的记录。

为了表达这种一对多的关系，我们需要在 `students` 表中假如一列 `class_id`，让它的值与 `classes` 表的某条记录相对应：

|id	|class_id	|name	|other columns...|
|--|--|--|--|
|1	|1	|小明	|...
|2	|1	|小红	|...
|5	|2	|小白	|...

这样，我们就可以根据 `class_id` 这个列直接定位出一个 `students` 表的记录应该对应到 `classes` 的哪条记录。

例如：

- 小明的 `class_id` 是 `1`，因此，对应的 `classes` 表的记录是 `id=1` 的一班；
- 小红的 `class_id` 是 `1`，因此，对应的 `classes` 表的记录是 `id=1` 的一班；
- 小白的 `class_id` 是 `2`，因此，对应的 `classes` 表的记录是 `id=1` 的一班。

在 `students` 表中，通过 `class_id` 的字段，可以把数据与另一张表关联起来，这种列称为 `外键`。

<u>外键并不是通过列名实现的，而是通过定义外键约束实现。</u>

```bash
ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
```

其中，外键约束的名称 `fk_class_id` 可以任意，`FOREIGN KEY (class_id)` 指定了 `class_id` 作为了外键，`REFERENCES classes (id)` 指定了这个外键将关联到 `classes` 表的 `id` 列（即 `classes` 表的主键）。

<u>通过定义外键约束，关系数据库可以保证无法插入无效的数据。</u>即如果 `classes` 表不存在 `id=99` 的记录，`students` 表就无法插入 `class_id=99` 的记录。

由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，`class_id` 仅仅是一个普通的列，只是它起到了外键的作用而已。

要删除一个外键约束，也是通过  `ALTER TABLE` 实现的：

```bash
ALTER TABLE students
DROP FOREIGN KEY fk_class_id;
```

⚠️：删除外键约束并没有删除外键这一列。删除列是通过 `DROP COLUMN ...` 实现的。

#### 多对多

通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，因此，班级表和老师表存在多对多关系。

<u>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</u>

`teachers` 表：

|id	|name|
|--|--|
|1	|张老师|
|2	|王老师|
|3	|李老师|
|4	|赵老师|

`classes` 表：

|id	|name|
|--|--|
|1	|一班|
|2	|二班|

中间表 `teacher_class` 关联两个一对多关系：

|id	|teacher_id	|class_id|
|--|--|--|
|1	|1	|1
|2	|1	|2
|3	|2	|1
|4	|2	|2
|5	|3	|1
|6	|4	|2

通过中间表 `teacher_class` 可知 `teachers` 到 `classes` 的关系：

- `id=1` 的张老师对应 `id=1,2` 的一班和二班；
- `id=2` 的王老师对应 `id=1,2` 的一班和二班；
- `id=3` 的李老师对应 `id=1` 的一班；
- `id=4` 的赵老师对应 `id=2` 的二班。

同理可知 `classes` 到 `teachers` 的关系：

- `id=1` 的一班对应 `id=1,2,3` 的张老师、王老师和李老师；
- `id=2` 的二班对应 `id=1,2,4` 的张老师、王老师和赵老师；

因此，**通过`中间表`，我们就定义了一个 “多对多”关系。**
 
#### 一对一

一对一关系是指，<u>一个表的记录对应到另一个表的`唯一一个`记录。</u>

例如，`students` 表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表 `contacts`，我们就可以得到一个“一对一”的关系：

|id	|student_id	|mobile|
|--|--|--|
|1	|1	|135xxxx6300
|2	|2	|138xxxx2209
|3	|5	|139xxxx8086

有细心的童鞋会问，既然是一对一关系，那为啥不给 `students` 表增加一个 `mobile` 列，这样就能合二为一了？

如果业务允许，完全可以把两个表合为一个表，<u>目的是把经常读取和不经常读取的字段分开，以获得更高的性能。</u>例如，把一个大的用户表分拆为用户基本信息表 `user_info` 表和用户详细信息表 `user_profiles`，大部分时候，只需要查询 `user_info` 表，并不需要查询 `user_profiles` 表，这样就提高了查询速度。

#### 小结

关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的罗就来保证。

在做前端应用的时候，也可以参考数据库的关系模型的思维，进行一对一、一对多、多对多的处理。

### 索引

在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要索引。

索引是关系数据库中对某一列或多个列的值进行`预排序`的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。

#### 唯一索引

#### 小结

通过对数据库表创建索引，可以提高查询速度。

通过创建唯一索引，可以保证某一列的值具有唯一性。

数据库索引对于用户和应用程序来说都是透明的。

## 查询数据

### 基本查询

### 条件查询

### 投影查询

### 排序

### 分页查询

### 聚合查询

### 多表查询

### 连接查询

## 修改数据

### INSERT

### UPDATE

### DELETE

## MySQL

### 管理 MySQL

要管理 MySQL，可以使用可视化图形界面 [MySQL Workbench](https://dev.mysql.com/downloads/workbench/)。

MySQL Workbench 可以用可视化的方式查询、创建和修改数据库表，但是，归根结底，MySQL Workbench 是一个图形客户端，它对 MySQL 的操作<u>仍然是发送 SQL 语句并执行。</u>因此，本质上，MySQL Workbench 和 MySQL Client 命令行都是客户端，和 MySQL 交互，`唯一的接口就是 SQL`。

因此，MySQL 提供了大量的 SQL 语句用于管理。虽然可以使用 MySQL Workbench 图形界面来直接管理 MySQL，但是，很多时候，通过 SSH 远程连接时，只能使用 SQL 命令，所以 ，了解并掌握常用的 SQL 管理操作是必须的。

使用 Node.js 连接 mysql：

```js
const mysql = require("mysql2"); // mysql driver

const config = {
  host: "localhost",
  user: "root",
  password: "msthink2020",
  database: "test",
};

// Create the connection pool.
const pool = mysql.createPool(config).promise();
console.log("pool =>", pool);

async function main() {
  try {
    let rows, fields, results;
    [rows, fields] = await pool.query(
      "SELECT * FROM students WHERE score >= ?",
      80
    );

    for (let row of rows) {
      console.log(row);
    }

    [results, fields] = await pool.execute("UPDATE students SET score = score - 5 WHERE score > ? AND score < ?", [80, 90]);
    console.log(`${results.changedRows} records are updated.`);

    pool.end();
  } catch (err) {
    console.log(err);
  }
}

main();
```

#### 数据库

在一个运行 MySQL 的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：

```bash
mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| learnjdbc          |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
6 rows in set (0.03 sec)
```

其中，`information_schema`、`mysql`、`performance_schema` 和 `sys` 是系统库，不要去改动它们。其他的是用户创建的数据库。

要创建一个新数据库，使用命令：

```bash
mysql> CRE
```

#### 表

列出当前数据库的所有表，使用命令：

```bash
mysql> SHOW TABLES;
+----------------+
| Tables_in_test |
+----------------+
| classes        |
| students       |
+----------------+
2 rows in set (0.04 sec)
```

#### 退出 MySQL

### 实用 SQL 语句

## 事务

### Read Uncommitted

### Read Committed

### Repeatable Read

### Serializable

## 数据库基础

### 什么是数据库

数据库（Database）是按照数据结构来组织、存储和管理数据的仓库（想象为一个文件柜 🗄️）。数据库保存有组织的数据的容器（通常是一个文件或一组文件），数据库是通过 DBMS（数据库管理系统）数据库软件创建和操纵的容器。直接访问文件的读写速度很慢，因此我们通常不直接访问数据库，而是使用 DBMS，替我们访问数据库。

### 关系型与非关系型

![](../.vuepress/public/images/2020-06-18-16-49-51-nosql-vs-sql.png)

### 表

> 表是某种特定类型数据的结构化清单。

将资料放入自己的文件柜时，先在文件柜创建文件，然后将相关的资料放入特定的文件中。在数据库领域中，这种文件成为表。表是一种结构化的文件，可用来存储某种特定类型的数据，如顾客清单、产品目录等。

注意的是，**存储在表中的数据是一种类型的数据是一种类型的数据或一个清单。**例如，不应该把顾客的清单与订单的清单存储在同一个数据表中（后端接口的提供，通常也是基于数据库表的组织来订，如根据顾客 id 获取订单列表）。数据库中的每个表都有一个名字，用来表识自己。此名字是唯一的，这表示数据库中没有其他表具有相同的名字。

#### 模式（schema）

> 模式是关于数据库和表的布局及特性的信息。

表具有一些特性，这些特性定义了数据在表中如何存储，如可以存储什么样的数据，数据如何分解，各部分信息如何命名等，描述表的这组信息就是所谓的模式。

### 列和数据类型

> 列（column），表中的一个字段。所有表都是由一个或多个列组成的。

表由列组成，列中存储着表中某部分的信息。我们可以将数据库表想象为一个网格，网格中每一列存储着一条特定的信息。例如，在顾客表中，一个列存储着顾客编号，一个列存储着顾客名。

要学会分解数据，正确地将数九分解为多个列极为重要。例如，城市、州、邮政编码应该总是独立的列，好处是可以更加方便地对特定的列进行数据的排序和过滤。

#### 数据类型

> 数据类型（datatype）所容许的数据的类型，每个表列都有相应的数据类型，它限制（或容许）该该列中存储的数据（防止出现在数值字段录入字符值）。

### 行

表中的数据是按行存储的，所保存的每个记录存储在自己的行内。如，顾客表中可以每行存储一个顾客，表中的行数为记录的总数。

### 主键

> 主键（primary key）一列（或一组列），其值能够唯一区分表中每个行。

表中每一行都应该有可以唯一表识自己的一列（或一组列），这个称为主键。例如，一个顾客表可以使用顾客编号列，而订单表可以使用订单 ID。

没有主键，更新或删除表中特定的行很困难，因为没有安全的方法保证只涉及相关的行。因此，我们应该总是定义主键，每个表具有一个主键。主键通常定义再表的一列上，但这并不是必需的，也可以一起使用多个列作为主键，但是必须保证所有列值的组合是唯一的。

一些约定好习惯

- 不更新主键列中的值；
- 不重用主键列的值；
- 不在主键列中使用可能会更改的值。（例如，使用一个名字作为主键以标识用户。）

## 什么是 SQL

SQL 是结构化查询语言（Structured Query Language）的缩写。SQL 是一种专门用来与数据库通信的语言。

## RDBMS

现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。

RDBMS 即关系数据库管理系统（Relational Database Management System）的特点：

1. 数据以表格的形式出现
2. 每行为各种记录名称
3. 每列为记录名称所对应的数据域
4. 许多的行和列组成一张表单
5. 若干的表单组成 database。

- **数据库**：数据库是一些关联表的集合。
- **数据表**：表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。
- **列**：一列（数据元素）包含了相同类型的数据，例如邮政编码的数据。
- **行**：一行（=元组或记录）是一组相关的数据，例如一条用户订阅的数据。
- **冗余**：存储两倍数据，冗余降低了性能，但提高了数据的安全性。
- **主键**：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。
- **外键**：外键用于关联两个表。
- **复合键**：复合键（组合键）将多个列作为一个索引键，一个用于复合索引。
- **索引**：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一个结构。类似书籍的目录。
- **参照完整性**：参照的完整性要求关系中不允许引用不存在的**实体**。实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。
  MySQL 为关系型数据库，这种所谓的“关系型”可以理解为“表格”的概念，一个关系型数据库由一个或数个表格组成，如图所示的一个表格：
  ![]()
- 表头：每一列的名称；
- 列（col）：具有相同数据类型的数据的集合；
- 行（row）：每一行用来描述某条记录的具体信息；
- 值（value）：行的具体信息，每个值必须与该列的数据类型相同；
- 键（key）：键的值在当前列中具有唯一性。

## 数据字典功能

### 什么是数据字典

数据字典存储有关数据的来源、说明、与其他数据的关系、用途和格式等信息，它本身就
是一个数据库，存储“关于数据项的数据”。数据字典是个指南，它为数据库提供了“路线图”，
而不是“原始数据”。

### 建立数据字典的目的

1. 提高开发效率，降低研制成本。数据字典是数据库开发者、数据监管人和用户之间的共同
   约定，是系统说明书的一个重要组成部分。一个统一的数据字典有助于开发者建立数据模型
   以及程序和数据库之间的数据转换接口，为规范化设计和实施数据管理系统铺平了道路。
2. 促进数据共享，提高数据的使用效率。通过数据字典，用户可以方便地知道每项数据的意
   义，了解数据的来源和使用方法，从而帮助用户迅速地找到所需的信息，并按照正确的方法
   使用数据。
3. 控制数据的使用。在某些特定的场合，可以通过对数据字典的控制达到控制数据使用的目的。

### 一个完整的数据字典至少应当包括以下内容：

- 数据集（系统）名称 数据集（系统）的正式名称
- 数据库名称 数据库文件的名称
- 数据名称 数据项的名称
- 数据存储名称 数据字段的名称
- 数据类型 数据的类型，如数字类型等
- 数据说明 关于数据含义的说明
- 数据存储长度 在计算机中数据存储的空间，用字节(BYTE)表示
- 单位 数据的测量单位
- 代码说明 使用的代码体系及编码规则
- 精密度 有效数字最低位数的位置
- 准确度 有效数字位数
- 数据的下限 数据合理的下限
- 数据的上限 数据合理的上限
- 获得数据的手段 数据测量的方法或引用的来源
- 时间和/或环境 获得数据的时间和/或环境
- 数据的例子 一个数据的实例

- [数据字典功能](https://blog.csdn.net/weixin_42476601/article/details/84261992) -- 数据字典详细应用

## 实战

## 参考资料

- [Mongodb 分片集群搭建](https://www.cnblogs.com/chenmh/p/8832902.html) -- 理论实践结合。
- mongodb 的安全使用（如果把它当做成 rdbms 使用会有什么问题）
- [SQL 教程](https://www.liaoxuefeng.com/wiki/1177760294764384)
